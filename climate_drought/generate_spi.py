import logging
import os
import sys
from os.path import expanduser
import subprocess
from pathlib import Path
from typing import List
from enum import Enum, unique, auto
from datetime import date, time, datetime
# handling NetCDF files
import xarray
import pandas as pd
import json
# Logging
logging.basicConfig(level=logging.DEBUG)


class Era5ProcessingBase:
    """
    Provides some basic functionality that can be used by different implementation specific strategies for different
    data sources
    """
    # Code to downloading data from the Copernicus Climate Data Store.
    # If the 'pixutils' module is installed this script should be located in the 'bin' directory of the Conda environment else setup link to pixutils

    era_download = "era_download.py"
    home = expanduser("~")
    python_env = os.path.join(home, "anaconda3/envs/climate_env/bin")
    ERA_DOWNLOAD_PY = os.path.join(python_env, era_download)
    if not os.path.exists(ERA_DOWNLOAD_PY):
        ERA_DOWNLOAD_PY = os.path.join("pixutils", era_download)

    if not os.path.exists(ERA_DOWNLOAD_PY):
        print("could not find {}, exiting".format(era_download))
        sys.exit(1)

    # Need to call from python env is not in bin folder
    if "pixutils" in ERA_DOWNLOAD_PY:
        ERA_DOWNLOAD_PY = r'{} {}'.format(os.path.join(python_env,"python"),ERA_DOWNLOAD_PY)


    #   target download time for each data source
    SAMPLE_TIME = time(hour=12, minute=0)

    def __init__(self, args, working_dir: str):
        """
        Initializer; should be called by derived classes
        :param args: program arguments
        :param working_dir: directory that will hold all files generated by the class
        """
        self.logger = logging.getLogger("ERA5_Processing")
        self.logger.setLevel(logging.DEBUG) if "verbose" in args and args.verbose else self.logger.setLevel(logging.INFO)
        self.args = args
        self.working_dir = working_dir

    @property
    def date_str(self) -> str:
        """
        Utility function to convert date to a defined string format
        :return: a date string formatted as "YYYY-MM" or "YYYY-MM-DD", depending on if a day is specified
        """
        return "{y:04}-{m:02}-{d:02}".format(y=self.args.year, m=self.args.month, d=self.args.day) \
            if 'day' in self.args else "{y:04}-{m:02}".format(y=self.args.year, m=self.args.month)

    def download(self) -> str:
        """
        This function handles downloading from the Copernicus Climate Service.
        Functionality should be suitable for most uses, but can be overridden by derived classes for more specialised
        downloads
        :return: path to the file containing the downloaded data
        """
        self.logger.info("Initiating download of ERA5 data.")
        self.logger.info("Variables to be downloaded: {}.".format(", ".join(self.VARIABLES)))

        self._download_era5_data(variables=self.VARIABLES,
                                 dates=self.args.dates,
                                 times=[self.SAMPLE_TIME],
                                 out_file=self.download_file_path)

        if os.path.isfile(self.download_file_path):
            self.logger.info("ERA5 data was downloaded to '{}'.".format(self.download_file_path))
        else:
            raise FileNotFoundError("ERA5 download file '{}' was missing.".format(self.download_file_path))

        return self.download_file_path

    def _download_era5_data(self, variables: List[str], dates: List[date], times: List[time], out_file: str) -> None:
        """
        Executes the ERA5 download script in a separate process.
        :param variables: a list of variables to be downloaded from the Copernicus Climate Data Store.
        :param dates: a list of dates to download data for
        :param times: a list of times to download data for
        :param out_file: output_file_path: path to the output file containing the requested fields.  Supported output format is NetCDF, determined by file extension.
        :return: nothing
        """

        if not os.path.exists(out_file):
            pexe = self.ERA_DOWNLOAD_PY.split(" ")
            if len(pexe) > 1:
                cmd = [pexe[0]]
                cmd.append(pexe[1])
            else:
                cmd = [self.ERA_DOWNLOAD_PY]
            cmd.extend(variables)
            cmd.extend(["--dates"] + [_date.strftime("%Y-%m-%d") for _date in dates])
            cmd.extend(["--times"] + [_time.strftime("%H:%M") for _time in times])
            cmd.extend(["--out_file", out_file])
            self.logger.info("Download: {}".format(cmd))

            proc = subprocess.run(cmd)
            if not proc.returncode == 0:
                raise RuntimeError("Download process returned unexpected non-zero exit code '{}'.".format(proc.returncode))

        if not os.path.isfile(out_file):
            raise FileNotFoundError("Output file '{}' could not be located.".format(out_file))

class Era5DailyPrecipProcessing(Era5ProcessingBase):
    """
    Specialisation of the base class for downloading and processing precipitation data
    """
    #   variables to be downloaded using the API
    VARIABLES = ["total_precipitation"]

    @property
    def download_file_path(self):
        """
        Returns the path to the file that will be downloaded
        :return: path to the file that will be downloaded
        """
        return os.path.join(self.working_dir, "precip_{d}.nc".format(d=self.date_str))

    @property
    def output_file_path(self):
        """
        Returns the path to the output file from processing
        :return: path to the output file
        """
        return os.path.join(self.working_dir, "spi_{d}.json".format(d=self.date_str))

    def __init__(self, args, working_dir: str):
        """
        Initializer.  Forwards parameters to super class.
        :param args: program arguments
        :param working_dir: directory that will hold all files generated by the class
        """
        super().__init__(args=args, working_dir=working_dir)
        self.logger.debug("Initiated ERA5 daily processing of temperature strategy.")

    def download(self) -> str:
        """
        Performs file downloads.  Currently uses the basic functionality offered by the base class
        :return: path to the file containing the downloaded data
        """
        return super().download()

    def process(self) -> str:
        """
        Carries out processing of the downloaded data.  This is the main functionality that is likely to differ between
        each implementation.
        :return: path to the output file generated by the algorithm
        """
        self.logger.info("Initiating processing of ERA5 daily data.")

        if not os.path.isfile(self.download_file_path):
            raise FileNotFoundError("Unable to locate downloaded data '{}'.".format(self.download_file_path))

        # Calculates SPI precipitation drought index
        self._convert_precip_to_spi(input_file_path=self.download_file_path, output_file_path=self.output_file_path)

        return self.output_file_path

    @staticmethod
    def _convert_precip_to_spi(input_file_path: str, output_file_path: str) -> None:
        """
        Calculates SPI precipitation drought index
        :param input_file_path: path to file containing precipitation
        :param output_file_path: path to file to be written containing SPI
        :return: nothing
        """

        # Extract data from NetCDF file
        datxr = xarray.open_dataset(input_file_path)
        print(datxr)

        # Select requested time slice
        subset = datxr.sel(time=slice('2000-01', '2020-12'))

        # Sum the available cells
        mean = subset.tp.sum(['latitude', 'longitude']).load()

        # Calculate SPI

        # Convert xarray to panda Series
        srs = mean.to_pandas()

        # Save as json file
        json_str = srs.to_json()
        with open(output_file_path, "w") as outfile:
            json.dump(json_str, outfile, indent=4)







